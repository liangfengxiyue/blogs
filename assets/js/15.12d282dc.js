(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{435:function(t,r,e){"use strict";e.r(r);var a=e(2),s=Object(a.a)({},(function(){var t=this,r=t._self._c;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h2",{attrs:{id:"语法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#语法"}},[t._v("#")]),t._v(" 语法")]),t._v(" "),r("p",[t._v("两种形式定义：声明（文字）和构造形式（new）"),r("br"),t._v("\n区别：在文字声明中可以添加多个键/值对，但是在构造形式中你必须逐个添加属性"),r("br"),t._v("\n注： null和undefined没有对应的构造形式，它们只有文字形式。相反，Date只有构造。")]),t._v(" "),r("h2",{attrs:{id:"类型"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#类型"}},[t._v("#")]),t._v(" 类型")]),t._v(" "),r("h3",{attrs:{id:"在javascript中一共有六种主要了类型"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#在javascript中一共有六种主要了类型"}},[t._v("#")]),t._v(" 在JavaScript中一共有六种主要了类型：")]),t._v(" "),r("p",[t._v("string\tnumber\tboolean\tnull\tnudefined\tobject"),r("br"),t._v("\n注意： 简单基本类型本身并不是对象。null有时会被当作一种对象类型，但是这其实是语言本身的一个bug。"),r("br"),t._v("\n原理：不同的对象在底层都表示为二进制，在JS中二进制前三位都为0的话会被判断为object类型，null的二进制表是全0，自然前三位也是0，所以执行typeof时会返回”object“。")]),t._v(" "),r("h3",{attrs:{id:"内置对象-复杂基本类型"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#内置对象-复杂基本类型"}},[t._v("#")]),t._v(" 内置对象（复杂基本类型）")]),t._v(" "),r("p",[t._v("String\tNumber\tBoolean\tObject\tFunction\tArray\tDate\tRegExp\tError"),r("br"),t._v("\n提示：小写的是类型，大写的是内置对象。"),r("br"),t._v("\n注：函数也是对象的一个子类型")]),t._v(" "),r("h2",{attrs:{id:"内容"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#内容"}},[t._v("#")]),t._v(" 内容")]),t._v(" "),r("p",[t._v("含义：对象的内容是由一些储存在特定命名位置的（任意类型）值组成的，我们称之为属性。")]),t._v(" "),r("h3",{attrs:{id:"访问属性的方式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#访问属性的方式"}},[t._v("#")]),t._v(" 访问属性的方式")]),t._v(" "),r("p",[t._v(".操作符 —— 属性访问"),r("br"),t._v("\n[]操作符 —— 键访问"),r("br"),t._v("\n区别：.操作符要求属性名满足标识符的命名规范，而[]语法可以接受任意的UTF-8/Unicdoe字符串作为属性名。"),r("br"),t._v("\n说明：UTF-8,是针对Unicode的一种可变长度字符编码。"),r("br"),t._v("\n注： 在对象中，属性名永远都是字符串。如果使用string以外的其他属性作为属性名，那它首先会被转为一个字符串。")]),t._v(" "),r("h3",{attrs:{id:"属性和方法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#属性和方法"}},[t._v("#")]),t._v(" 属性和方法")]),t._v(" "),r("p",[t._v("从技术的角度上来说，函数永远不会”属于“一个对象，因为this是在运行时根据调用位置动态绑定的，所以函数和对象的关系最多也只能说是间接关系。")]),t._v(" "),r("h3",{attrs:{id:"复制对象"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#复制对象"}},[t._v("#")]),t._v(" 复制对象")]),t._v(" "),r("p",[t._v("深拷贝：JSON序列化"),r("br"),t._v("\n浅拷贝：=操作符，object.assign(目标对象，源对象)"),r("br"),t._v("\n注： 由于object.assign()就是通过使用=操作符来赋值，所以源对象属性的一些特性（比如writable）不会被复制到目标对象。")]),t._v(" "),r("h3",{attrs:{id:"属性描述符"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#属性描述符"}},[t._v("#")]),t._v(" 属性描述符")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("var myObject = {\n    a: 2\n}\nconsole.log(Object.getOwnPropertyDescriptor(myObject, \"a\"));\nObject.defineProperty(myObject, 'b', {\n    value: 3,\n    writable: true,\n    configurable: true,\n    enumerable: true\n})\nconsole.log(myObject.b);\n")])])]),r("p",[t._v("writable：是否可以修改属性的值"),r("br"),t._v("\nconfigurable：是否可以配置"),r("br"),t._v("\nenumerable：是否可以枚举")]),t._v(" "),r("h3",{attrs:{id:"不变性"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#不变性"}},[t._v("#")]),t._v(" 不变性")]),t._v(" "),r("p",[t._v("含义：希望属性或者对象是不可改变的"),r("br"),t._v("\n实现方法："),r("br"),t._v("\n1.对象常量："),r("br"),t._v("\n结合writable:false和configurable:false就可以创建一个真正的常量。"),r("br"),t._v("\n2.禁止扩展（禁止添加新属性并且保留已有属性）：Object.preventeExtensions()"),r("br"),t._v("\n3.密封：Object.seal()会创建一个”密封“的对象"),r("br"),t._v("\n密封后不仅不能添加新属性，也不能重新配置或者删除任何现有属性（虽然可以修改属性的值）。"),r("br"),t._v("\n4.冻结：Object.freeze()"),r("br"),t._v("\n会创建一个冻结对象，实际上会在现有对象上调用Object.seal()并把所有”数据访问“属性标记为writable:fasle")]),t._v(" "),r("h3",{attrs:{id:"get-访问"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#get-访问"}},[t._v("#")]),t._v(" [[GET]]：访问")]),t._v(" "),r("p",[t._v("对象默认的内置[[GET]]操作首先在对象中查找是否有名称相同的属性，如果找到就会返回这个属性的值。")]),t._v(" "),r("h3",{attrs:{id:"put-赋值"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#put-赋值"}},[t._v("#")]),t._v(" [[PUT]]：赋值")]),t._v(" "),r("p",[t._v("如果已经存在这个属性，[[PUT]]算法大致会检查下面这些内容："),r("br"),t._v("\n1.属性是否是访问描述符？如果是并且存在setter就调用getter"),r("br"),t._v("\n2.属性的数据描述符中writable是否为false？如果是，在非严格模式下静默失败，在严格模式下抛出TypeError异常。"),r("br"),t._v("\n3.如果都不是，将该值设为属性的值。")]),t._v(" "),r("h3",{attrs:{id:"getter和setter"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#getter和setter"}},[t._v("#")]),t._v(" Getter和Setter")]),t._v(" "),r("p",[t._v("getter是一个隐藏函数，会在获取属性值时调用；setter也是一个隐藏函数，会在设置属性时调用。"),r("br"),t._v("\n访问描述符：当你给一个属性定义getter、setter或者两者都有时，这个属性会被定义为访问数据符\n数据描述符：与访问描述符相对。")]),t._v(" "),r("h3",{attrs:{id:"存在性"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#存在性"}},[t._v("#")]),t._v(" 存在性")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("var myObject = {\n    a: 2\n}\nconsole.log(\"a\" in myObject);  //true\nconsole.log(\"b\" in myObject);   // false\nconsole.log(myObject.hasOwnProperty('a'));  //true\nconsole.log(myObject.hasOwnProperty('b'));  // false\n")])])]),r("p",[t._v("in操作符会检查属性是否存在对象及其[[Prototype]]原型链中"),r("br"),t._v("\nhasOwnProperty只会检查属性是否在对象中，不会检查[[Prototype]]链"),r("br"),t._v("\n枚举：enumerable值是否为true"),r("br"),t._v("\n可以通过in操作符来判断；也可以通过propertyIsEnumerable（），会检查给定的属性名是否直接存在于对象中，而不是在原型链中，并且满足enumerable：true。")]),t._v(" "),r("h3",{attrs:{id:"遍历"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#遍历"}},[t._v("#")]),t._v(" 遍历")]),t._v(" "),r("p",[t._v("for ... in循环可以用来遍历对象的可枚举属性列表（包括[[prototype]]链）\t获取属性或者下标"),r("br"),t._v("\nforEach()会遍历数组中的所有值并忽略回调函数的返回值"),r("br"),t._v("\nevery()会一直运行到回调函数返回false（或者假值）"),r("br"),t._v("\nsome()会一直运行直到回调函数返回true（或者真值）\t"),r("br"),t._v("\nfor..of循环遍历数组\t\t获取值"),r("br"),t._v("\n注： 最好只在对象上使用for in，因为普通对象没有内置的iterator。数组有内置的iterator对象，所以可以直接用在数组上。"),r("br"),t._v("\nfor of循环首先会向被访问对象请求一个迭代器对象，然后通过调用迭代器对象的next()方法来遍历所有返回值。"),r("br"),t._v("\niterator本身并不是一个迭代器对象，而是返回迭代器对象的函数。")])])}),[],!1,null,null,null);r.default=s.exports}}]);