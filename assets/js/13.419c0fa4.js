(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{433:function(t,r,n){"use strict";n.r(r);var s=n(2),e=Object(s.a)({},(function(){var t=this,r=t._self._c;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h3",{attrs:{id:"this到底是什么"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#this到底是什么"}},[t._v("#")]),t._v(" this到底是什么?")]),t._v(" "),r("p",[t._v("this是在运行时绑定的，并不是在编写时绑定，它的上下文取决于函数调用时的各种条件。this的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。")]),t._v(" "),r("h3",{attrs:{id:"关于this的误区"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#关于this的误区"}},[t._v("#")]),t._v(" 关于this的误区")]),t._v(" "),r("p",[t._v("1.指向本身"),r("br"),t._v("\n2.指向函数的作用域")]),t._v(" "),r("h3",{attrs:{id:"判断this指向的四种条件-优先级从高到低"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#判断this指向的四种条件-优先级从高到低"}},[t._v("#")]),t._v(" 判断this指向的四种条件（优先级从高到低）")]),t._v(" "),r("p",[t._v("1.由new调用，绑定到新创建的对象。\t（new关键词绑定）"),r("br"),t._v("\n2.由call或者apply(或者bind)调用，绑定到指定对象，第一个参数就是指定的对象。\t（显示绑定）"),r("br"),t._v("\n3.由上下文对象调用，绑定到那个上下文对象。\t\t（隐式绑定）"),r("br"),t._v("\n4.在严格模式下绑定到undefined，否则绑定到全局对象。\t\t（默认绑定）"),r("br"),t._v("\n注意： ES6中的箭头函数并不会使用四条标准的绑定规则，而是根据当前的词法作用域来决定this，具体来说，箭头函数会继承外层函数调用的this的绑定（无论绑定的是什么）"),r("br"),t._v("\n细节："),r("br"),t._v("\n在JS中，构造函数只是使用new操作符时被调用的函数。"),r("br"),t._v("\n使用new来调用函数，会自动执行的操作："),r("br"),t._v("\n1.创建（或者说构造）一个全新对象"),r("br"),t._v("\n2.这个新对象会被执行[[Prototype]]连接"),r("br"),t._v("\n3.这个新对象会绑定到函数调用的this"),r("br"),t._v("\n4.如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象"),r("br"),t._v("\n隐式绑定："),r("br"),t._v("\n对象属性引用链中只有上层或者说最后一层在调用位置中起作用"),r("br"),t._v("\n创建空对象：Object.created(null)。Object.created和{}很像，但是并不会创建Object.prototype这个委托，所以它比{}更空。")])])}),[],!1,null,null,null);r.default=e.exports}}]);