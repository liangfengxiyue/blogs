(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{431:function(a,t,r){"use strict";r.r(t);var n=r(2),s=Object(n.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h3",{attrs:{id:"分类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#分类"}},[a._v("#")]),a._v(" 分类")]),a._v(" "),t("p",[a._v("动态作用域"),t("br"),a._v("\n词法作用域：JS语法采用的是这个"),t("br"),a._v("\n区别："),t("br"),a._v("\n词法作用域是在写代码或者定义时确定的，而动态作用域实在运行时确定的（this也是）。"),t("br"),a._v("\n词法作用域关注函数在何处声明，而动态作用域关注函数从何处调用。")]),a._v(" "),t("h3",{attrs:{id:"编译三步骤"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#编译三步骤"}},[a._v("#")]),a._v(" 编译三步骤")]),a._v(" "),t("ol",[t("li",[a._v("分词/语法分析：将由字符组成的字符串分解成有意义的代码块，这些代码块被称为词法单元。")]),a._v(" "),t("li",[a._v("解析/语法分析：将词法单元流（数组）转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树。（抽象语法树——AST）")]),a._v(" "),t("li",[a._v("代码生成：将AST转换为可执行代码的过程。")])]),a._v(" "),t("h3",{attrs:{id:"lhs和rhs"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#lhs和rhs"}},[a._v("#")]),a._v(" LHS和RHS")]),a._v(" "),t("p",[a._v("LHS：赋值操作的目标是谁（set）"),t("br"),a._v("\nRHS：谁是赋值操作的源头（get）")]),a._v(" "),t("h3",{attrs:{id:"作用域嵌套"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#作用域嵌套"}},[a._v("#")]),a._v(" 作用域嵌套")]),a._v(" "),t("p",[a._v("引擎从当前的执行作用域开始查找变量，如果找不到，就向上一级继续查找。当抵达最外层的全局作用域时，无论找到还是没找到，查找过程都会停止。")]),a._v(" "),t("h3",{attrs:{id:"词法作用域"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#词法作用域"}},[a._v("#")]),a._v(" 词法作用域")]),a._v(" "),t("p",[a._v("概念：词法化的过程会对源代码中的字符进行检查，如果是有状态的解析过程，还会赋予单词语义。\n词法作用域是由你在写代码时将变量和块级作用域写在哪里来决定的。"),t("br"),a._v("\n查找：作用域查找始终从运行时所处的最内部作用域开始， 逐级向外或者向上进行，直到遇见第一个匹配的标识符为止。"),t("br"),a._v("\n注意：无论函数在哪里被调用，也无论它如何被调用，它的词法作用域只由函数被声明时所处的位置决定的。\n欺骗词法：(影响性能，不提倡使用)"),t("br"),a._v("\neval(...)")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("function foo(a) {\n    eval('var a = 2')\n    console.log(a);\n}\nfoo(1)\n")])])]),t("p",[a._v("with")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("var o1 = {\n    a: 1,\n    b: 2,\n    c: 3\n}\nwith(o1) {\n    a = 1\n    b = 2\n    c = 3\n    d = 4 //    相当于做了LHS的引用，在全局作用域中创建了变量b  可以理解为var d = 4\n    let e = 5 //    ReferenceError  使用let限制在了with的作用域中\n}\nconsole.log(o1.d);  //undefined\nconsole.log(d);     //4\nconsole.log(e);\n")])])]),t("h3",{attrs:{id:"函数作用域"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#函数作用域"}},[a._v("#")]),a._v(" 函数作用域")]),a._v(" "),t("p",[a._v("含义：属于这个函数的全部变量都可以在整个函数的范围内使用及复用（事实上在嵌套的作用域中也可以使用）")]),a._v(" "),t("h4",{attrs:{id:"为什么-隐藏-变量和函数是一个有用的技术"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#为什么-隐藏-变量和函数是一个有用的技术"}},[a._v("#")]),a._v(" 为什么“隐藏”变量和函数是一个有用的技术？")]),a._v(" "),t("p",[a._v("有很多原因促成了这种基于作用域的隐藏方法，它们大都是从最小的特权原则中引申出来的，也叫最小授权或最小暴露原则。")]),a._v(" "),t("h4",{attrs:{id:"函数声明式与函数表达式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#函数声明式与函数表达式"}},[a._v("#")]),a._v(" 函数声明式与函数表达式")]),a._v(" "),t("p",[a._v("声明式：function iife（）{}"),t("br"),a._v("\n表达式：（function iife（）{}）（...）   ||\t（function iife（）{}（...））"),t("br"),a._v("\n区别：名称标识符将会绑定在何处。"),t("br"),a._v("\n注：如果function是声明中的第一个词，那么就是一个函数声明式，否则就是一个函数表达式。"),t("br"),a._v("\n作用域问题：iife作为函数表达式意味着iife只能在...所代表的位置中被访问，外部作用域则不行。")]),a._v(" "),t("h4",{attrs:{id:"匿名和具名"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#匿名和具名"}},[a._v("#")]),a._v(" 匿名和具名")]),a._v(" "),t("p",[a._v("函数表达式可以是匿名的，而函数声明则不可以省略函数名——在js的语法中这是非法的。")]),a._v(" "),t("h4",{attrs:{id:"立即执行函数表达式iife"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#立即执行函数表达式iife"}},[a._v("#")]),a._v(" 立即执行函数表达式IIFE")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("(function() {\n\n})()\n两种写法\n(function() {\n\n}())\n")])])]),t("p",[a._v("也可以在()中携带参数")]),a._v(" "),t("h4",{attrs:{id:"块级作用域"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#块级作用域"}},[a._v("#")]),a._v(" 块级作用域")]),a._v(" "),t("p",[a._v("let const"),t("br"),a._v("\n声明：属于一个新的作用域而不是当前的函数作用域（也不属于全局作用域）"),t("br"),a._v("\n变量提升：当用var声明变量时，它写在哪里都是一样的，因为它们最终都会属于外部作用域"),t("br"),a._v("\n提升：是指声明会被视为存在于其所出现的作用域的整个范围内。"),t("br"),a._v("\n垃圾收集：块级作用域可以清楚的让引擎知道代码块是否有必要继续保持。")]),a._v(" "),t("h4",{attrs:{id:"提升"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#提升"}},[a._v("#")]),a._v(" 提升")]),a._v(" "),t("p",[a._v("包括变量和函数在内的所有声明都会在任何代码执行前首先被处理。"),t("br"),a._v("\nvar a = 2;"),t("br"),a._v("\n在编译阶段会被看成两部，第一部分声明：var a;第二部分 a = 2;"),t("br"),a._v("\n第一部分发生在代码编译时，第二部分则实在代码执行时。"),t("br"),a._v("\n也就是说，代码是先声明在赋值的。"),t("br"),a._v("\n注意：  只有声明本身会被提升，而赋值或其他运行逻辑会留在原地（编写代码时的位置），即不会发生提升。\n函数优先：函数声明和变量声明都会被提升，在有多个重复声明的代码中，是函数会首先被提升，然后才是变量。但也因此会造成“遮蔽效应”，即作用域在匹配到第一个标识符时，便会停止，忽略后面的同名标识符。"),t("br"),a._v(" "),t("strong",[a._v("一个普通块内部的函数声明通常会被提升到所在作用域的顶部，也是为什么函数优先的原因。")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("console.log(a);     //变量提升 - 函数提升       function a() {...}\nvar a;\nfunction a() {\n    console.log('function a');\n}\n")])])]),t("h3",{attrs:{id:"作用域闭包"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#作用域闭包"}},[a._v("#")]),a._v(" 作用域闭包")]),a._v(" "),t("p",[a._v("闭包的定义：当函数可以记住并访问所在的词法作用域，即使函数实在当前词法作用域之外执行，这时就产生了闭包。"),t("br"),a._v("\n模块的特征："),t("br"),a._v("\n1.为创建内部函数作用域而调用了一个包装函数"),t("br"),a._v("\n2.包装函数的返回值必须至少包括一个对内部函数的引用。")])])}),[],!1,null,null,null);t.default=s.exports}}]);