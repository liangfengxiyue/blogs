(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{432:function(r,t,a){"use strict";a.r(t);var e=a(2),o=Object(e.a)({},(function(){var r=this,t=r._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":r.$parent.slotKey}},[t("h3",{attrs:{id:"概念"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#概念"}},[r._v("#")]),r._v(" 概念")]),r._v(" "),t("p",[r._v("JS中表示集合的数据结构主要是：Array、Object、Set、Map。\nIterator就是一种统一的接口机制，为不同的数据结构提供统一的访问机制。"),t("br"),r._v("\n遍历器接口：Iterable\t指针对象：Iterator")]),r._v(" "),t("h3",{attrs:{id:"作用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#作用"}},[r._v("#")]),r._v(" 作用")]),r._v(" "),t("ol",[t("li",[r._v("为各种数据结构提供一个统一的、简便的访问接口")]),r._v(" "),t("li",[r._v("使得数据结构的成员能够按照某种次序排列")]),r._v(" "),t("li",[r._v("供for...of使用")])]),r._v(" "),t("h3",{attrs:{id:"遍历过程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#遍历过程"}},[r._v("#")]),r._v(" 遍历过程")]),r._v(" "),t("ol",[t("li",[r._v("创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象的本质就是一个指针对象。")]),r._v(" "),t("li",[r._v("第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员")]),r._v(" "),t("li",[r._v("第二次调用指针对象的next方法，可以将指针指向数据结构的第二个成员")]),r._v(" "),t("li",[r._v("不断调用指针对象的next方法，直到它指向数据结构的结束位置"),t("br"),r._v("\n每次调用next方法都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含value和done两个属性的对象。其中value是成员的值，done属性是一个布尔值，表示遍历是否结束（false-继续，true-结束）。")])]),r._v(" "),t("h3",{attrs:{id:"默认带有iterator接口的数据结构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#默认带有iterator接口的数据结构"}},[r._v("#")]),r._v(" 默认带有Iterator接口的数据结构")]),r._v(" "),t("p",[r._v("● Array"),t("br"),r._v("\n● Map"),t("br"),r._v("\n● Set"),t("br"),r._v("\n● String"),t("br"),r._v("\n● TypedArray"),t("br"),r._v("\n● 函数的arguments对象"),t("br"),r._v("\n● NodeList对象（类数组对象）"),t("br"),r._v("\n本质上，遍历器是一种线性处理，对于任何非线性的数据结构，部署遍历器接口就等于部署一种线性转换。")]),r._v(" "),t("h3",{attrs:{id:"调用iterator接口的场景"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#调用iterator接口的场景"}},[r._v("#")]),r._v(" 调用Iterator接口的场景")]),r._v(" "),t("p",[r._v("解构赋值：对数组和Set结构进行解构赋值时，会默认调用[Symbol.Iterator]方法"),t("br"),r._v("\n拓展运算符(...)"),t("br"),r._v("\nyield*：yield*后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口。"),t("br"),r._v("\n例：")]),r._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[r._v("let generator = function* () {\n  yield 1;\n  yield* [4, 5, 6]\n  yield 7;\n}\nvar it = generator()\nconsole.log(it.next()); // 1\nconsole.log(it.next()); // 4\nconsole.log(it.next()); // 5\nconsole.log(it.next()); // 6\nconsole.log(it.next()); // 7\nconsole.log(it.next()); // undefined\n")])])]),t("p",[r._v("其他场合：由于数组的遍历会调用遍历器接口，所以任何接受数组作为参数的场合其实都调用了遍历器接口。"),t("br"),r._v("\n例："),t("br"),r._v("\n● for...of"),t("br"),r._v("\n● Array.form()"),t("br"),r._v("\n● Map()、Set()、WeakMap()、weakSet()"),t("br"),r._v("\n● Promise.all()"),t("br"),r._v("\n● promise.race()")]),r._v(" "),t("h3",{attrs:{id:"遍历器对象的return"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#遍历器对象的return"}},[r._v("#")]),r._v(" 遍历器对象的return()")]),r._v(" "),t("p",[r._v("return方法的使用场景是，如果for..of循环提前退出(通常是因为出错，或者有break语句或continue语句)，就会调用return方法；如果一个对象在完成遍历前需要清理或释放资源，就可以部署return方法。"),t("br"),r._v("\n注：return方法必须返回一个对象，这是Generator规格决定的。")]),r._v(" "),t("h3",{attrs:{id:"for-of循环"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#for-of循环"}},[r._v("#")]),r._v(" for...of循环")]),r._v(" "),t("p",[r._v("一个数据结构只要部署了Symbol.iterator属性，就被视为具有iterator接口，就可以用for...of循环遍历它的成员。也就是说，for...of循环内部调用的是数据结构的Symbol.iterator方法。")]),r._v(" "),t("h4",{attrs:{id:"数组"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数组"}},[r._v("#")]),r._v(" 数组")]),r._v(" "),t("p",[r._v("for...of循环可以代替数组实例的forEach方法。"),t("br"),r._v("\n注：for...of循环调用遍历器接口，数组的遍历器接口只返回具有数字索引的属性")]),r._v(" "),t("h4",{attrs:{id:"map和set结构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#map和set结构"}},[r._v("#")]),r._v(" Map和Set结构")]),r._v(" "),t("ol",[t("li",[r._v("遍历的顺序是按照各个成员被添加进数据结构的顺序")]),r._v(" "),t("li",[r._v("Set结构遍历时返回的是一个值，而Map结构遍历时返回的时一个数组，该数组的两个成员分别为当前Map成员的键名和键值。")])]),r._v(" "),t("h4",{attrs:{id:"计算生成的数据结构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#计算生成的数据结构"}},[r._v("#")]),r._v(" 计算生成的数据结构")]),r._v(" "),t("p",[r._v("ES6的数组、Set、Map都部署了以下三个方法，调用后都返回遍历器对象"),t("br"),r._v("\n● entrise()返回一个遍历器对象，用于遍历[键名, 键值]组成的数组。对于Set结构，键名与键值相同。Map结构的iterator接口默认就是调用entrise()。"),t("br"),r._v("\n● keys()返回一个遍历器对象，用于遍历所有的键名"),t("br"),r._v("\n● values()返回一个遍历器对象，用于遍历所有的键值")]),r._v(" "),t("h4",{attrs:{id:"类数组的对象"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#类数组的对象"}},[r._v("#")]),r._v(" 类数组的对象")]),r._v(" "),t("p",[r._v("并不是所有类似数组的对象都具有iterator接口，可以使用Array.form()将其转为数组。")]),r._v(" "),t("h4",{attrs:{id:"对象"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#对象"}},[r._v("#")]),r._v(" 对象")]),r._v(" "),t("p",[r._v("对于普通的对象，不能使用for...of循环，因为没有Iterator接口。但是可以用for...in循环遍历键名。\n解决办法：")]),r._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[r._v("for (let key of Object.keys(obj)) {\n  console.log(obj[key]);\n}\n")])])]),t("h3",{attrs:{id:"for-of循环与其他循环的比较"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#for-of循环与其他循环的比较"}},[r._v("#")]),r._v(" for...of循环与其他循环的比较")]),r._v(" "),t("h4",{attrs:{id:"其他for循环的缺点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#其他for循环的缺点"}},[r._v("#")]),r._v(" 其他for循环的缺点")]),r._v(" "),t("p",[r._v("● for循环，写法麻烦"),t("br"),r._v("\n● forEach循环，breck命令和return命令都不能奏效。（可以使用异常强制跳出）"),t("br"),r._v("\n● for...in循环的缺点"),t("br"),r._v("\na. 数组的键名是数字，但是for...in循环是以字符串作为键名，'0','1','2'等。"),t("br"),r._v("\nb. for...in循环不仅可以遍历数字，还会遍历手动添加的其他键，甚至包括原型链上的键。"),t("br"),r._v("\nc. 某写情况下，for...in循环会以任意顺序遍历键名"),t("br"),r._v("\n总之，for...in循环主要是为了遍历对象而设计的，不适用与遍历数组")]),r._v(" "),t("h4",{attrs:{id:"for-of循环的优点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#for-of循环的优点"}},[r._v("#")]),r._v(" for...of循环的优点：")]),r._v(" "),t("p",[r._v("● 有着同for...in的简洁语法，但是没有for...in的那些缺点"),t("br"),r._v("\n● 不用于forEach方法，它可以与break、continue和return配合使用"),t("br"),r._v("\n● 提供了遍历所有数据结构的统一操作接口")])])}),[],!1,null,null,null);t.default=o.exports}}]);