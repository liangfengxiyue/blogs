(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{434:function(a,t,e){"use strict";e.r(t);var r=e(2),s=Object(r.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h2",{attrs:{id:"set"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#set"}},[a._v("#")]),a._v(" Set")]),a._v(" "),t("h3",{attrs:{id:"含义"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#含义"}},[a._v("#")]),a._v(" 含义")]),a._v(" "),t("p",[a._v("类似于数组，但是成员的值是唯一的，没有重复。Set本身是一个构造函数，用来生成Set数据结构。")]),a._v(" "),t("h3",{attrs:{id:"基本用法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#基本用法"}},[a._v("#")]),a._v(" 基本用法")]),a._v(" "),t("p",[a._v("Set函数可以接受一个数组（或者具有Iterator接口的其他数据结构）作为参数，用来初始化。\n例：")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("const set = new Set([1, 2, 3, 4, 4])\nconsole.log([...set]); // [1, 2, 3, 4]\n[...new Set(Array)] // 去重\n")])])]),t("p",[a._v("注：\n向Set加入值时不会发生类型转换（隐式转换），所以string类型的值和number类型的值，是不同的两个值。比如：5和'5'。"),t("br"),a._v("\nSet内部判断两个值是否相同时使用的算法叫作“Same-value equality”，它类似于精准确相等运算符（===）。两者主要区别在于，NaN等于自身，而精确运算符认为NaN不等于自身。"),t("br"),a._v("\n另外，在Set中两个对象总是不相等的。")]),a._v(" "),t("h3",{attrs:{id:"set的实例与方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#set的实例与方法"}},[a._v("#")]),a._v(" Set的实例与方法")]),a._v(" "),t("h4",{attrs:{id:"实例"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#实例"}},[a._v("#")]),a._v(" 实例")]),a._v(" "),t("p",[a._v("● Set.prototype.constructor：构造函数，默认就是Set函数。"),t("br"),a._v("\n● Set.prototype.size：返回set实例的成员总数。")]),a._v(" "),t("h4",{attrs:{id:"方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#方法"}},[a._v("#")]),a._v(" 方法")]),a._v(" "),t("p",[a._v("● add(value)：添加某个值，返回Set结构本身。"),t("br"),a._v("\n● delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。"),t("br"),a._v("\n● has(value)：返回一个布尔值，表示参数是否为Set的成员。"),t("br"),a._v("\n● clear()：清楚所有成员，没有返回值。"),t("br"),a._v("\n注：Array.from()可以将Set结构转为数组，使用[...]拓展运算符也可以。")]),a._v(" "),t("h3",{attrs:{id:"遍历操作"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#遍历操作"}},[a._v("#")]),a._v(" 遍历操作")]),a._v(" "),t("p",[a._v("● keys()：返回键名的遍历器"),t("br"),a._v("\n● values()：返回键值的遍历器"),t("br"),a._v("\n● entries()：返回键值对的遍历器"),t("br"),a._v("\n● forEach()：使用回调函数遍历每个成员"),t("br"),a._v("\n注：Set的遍历顺序是插入顺序。在使用Set保存一个回调函数列表，调用时就能保证按照添加顺序调用。")]),a._v(" "),t("h4",{attrs:{id:"keys-、values-、entries"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#keys-、values-、entries"}},[a._v("#")]),a._v(" keys()、values()、entries()")]),a._v(" "),t("p",[a._v("keys()、values()、entries()返回都是遍历器对象。"),t("br"),a._v("\nSet结构的实例默认可遍历，其默认遍历器生成函数就是它的values()，如下：")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("Set.prototype[Symbol.iterator] === Set.prototype.values // true\n")])])]),t("h4",{attrs:{id:"foreach"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#foreach"}},[a._v("#")]),a._v(" forEach")]),a._v(" "),t("p",[a._v("forEach(fn, thisArg)：用于对每个成员执行某种操作，没有返回值。"),t("br"),a._v("\n第一个参数fn是一个处理函数，第二个参数表示绑定的this对象。")]),a._v(" "),t("h3",{attrs:{id:"改变原来set结构的方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#改变原来set结构的方法"}},[a._v("#")]),a._v(" 改变原来Set结构的方法")]),a._v(" "),t("p",[a._v("● 利用原Set结构映射出一个新的结构，然后赋值给原来的Set结构"),t("br"),a._v("\n● 利用Array.from()"),t("br"),a._v("\n例：")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("let arr = new Set([1, 2, 3, 4])\narr = new Set([...arr].map(val => val * 2)) // 2 4 6 8\narr = Array.from(arr, val => val * 2)  // 2 4 6 8\n")])])]),t("h4",{attrs:{id:"拓展"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#拓展"}},[a._v("#")]),a._v(" 拓展：")]),a._v(" "),t("p",[a._v("Array.from(arrayLike, mapfn, thisArg)：静态方法从可迭代或类数组对象创建一个新的浅拷贝的数组实例。"),t("br"),a._v("\n三个参数："),t("br"),a._v("\narrayLike(必写)：想要转换数组的类数组对象或可迭代对象"),t("br"),a._v("\nmapfn(可选)：调用数组每个元素的函数"),t("br"),a._v("\nthiaArg(可选)：执行mapfn时用作this的值（this的指向）")]),a._v(" "),t("h2",{attrs:{id:"weakset"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#weakset"}},[a._v("#")]),a._v(" WeakSet")]),a._v(" "),t("h3",{attrs:{id:"含义-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#含义-2"}},[a._v("#")]),a._v(" 含义")]),a._v(" "),t("p",[a._v("weakSet结构与Set类似，也是不重复的值的集合。")]),a._v(" "),t("ol",[t("li",[a._v("WeakSet的成员只能是对象，而不能是其他类型的值。")]),a._v(" "),t("li",[a._v("WeakSet中的对象都是弱引用，即垃圾回收机制不考虑WeakSet对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象是否还存在于WeakSet中。"),t("br"),a._v("\n因此ES6规定WeakSet不可遍历。")])]),a._v(" "),t("h3",{attrs:{id:"语法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#语法"}},[a._v("#")]),a._v(" 语法")]),a._v(" "),t("p",[a._v("const ws = new WeakSet()"),t("br"),a._v("\n作为构造函数，weakSet可以接受一个数组或类似数组的对象作为参数。实际上具有iterator接口的对象都可以。")]),a._v(" "),t("h3",{attrs:{id:"方法-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#方法-2"}},[a._v("#")]),a._v(" 方法")]),a._v(" "),t("p",[a._v("与Set相同，唯一的差别在于没有forEach()。原因在于WeakSet()不可遍历"),t("br"),a._v("\n● add()"),t("br"),a._v("\n● delete()"),t("br"),a._v("\n● has()")]),a._v(" "),t("h2",{attrs:{id:"map"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#map"}},[a._v("#")]),a._v(" Map")]),a._v(" "),t("h3",{attrs:{id:"含义-3"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#含义-3"}},[a._v("#")]),a._v(" 含义")]),a._v(" "),t("p",[a._v("类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。")]),a._v(" "),t("h3",{attrs:{id:"基本用法-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#基本用法-2"}},[a._v("#")]),a._v(" 基本用法")]),a._v(" "),t("p",[a._v("const map = new Map()"),t("br"),a._v("\n注：Map的键实际上是和内存地址绑定的，只要内存地址不一样，就视为两个键。"),t("br"),a._v("\n另外，如果Map的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map就将其视为一个键，包括0和-0。")]),a._v(" "),t("h3",{attrs:{id:"map实例的属性和方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#map实例的属性和方法"}},[a._v("#")]),a._v(" Map实例的属性和方法")]),a._v(" "),t("h4",{attrs:{id:"属性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#属性"}},[a._v("#")]),a._v(" 属性")]),a._v(" "),t("p",[a._v("size属性：返回Map结构的成员总数。")]),a._v(" "),t("h4",{attrs:{id:"方法-3"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#方法-3"}},[a._v("#")]),a._v(" 方法")]),a._v(" "),t("p",[a._v("● set()：设置key所对应的键值。"),t("br"),a._v("\n● get()：读取key对应的键值。"),t("br"),a._v("\n● delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。"),t("br"),a._v("\n● has(value)：返回一个布尔值，表示参数是否为Set的成员。"),t("br"),a._v("\n● clear()：清楚所有成员，没有返回值。"),t("br"),a._v("\n注：Map的遍历顺序是插入顺序。在使用Set保存一个回调函数列表，调用时就能保证按照添加顺序调用。\nMap结构的默认遍历器接口（Symbol.iterator属性）就是entries()。")]),a._v(" "),t("h2",{attrs:{id:"weakmap"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#weakmap"}},[a._v("#")]),a._v(" WeakMap")]),a._v(" "),t("h3",{attrs:{id:"含义-4"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#含义-4"}},[a._v("#")]),a._v(" 含义")]),a._v(" "),t("p",[a._v("weakMap结构与Map的结构类似，也用于生成键值对的集合。")]),a._v(" "),t("h3",{attrs:{id:"区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#区别"}},[a._v("#")]),a._v(" 区别")]),a._v(" "),t("ol",[t("li",[a._v("weakMap只接受对象作为键名（null除外）,不接受其他类型的值作为键名。")]),a._v(" "),t("li",[a._v("weakMap的键名所指向的对象不计入垃圾回收机制。")])]),a._v(" "),t("h3",{attrs:{id:"语法-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#语法-2"}},[a._v("#")]),a._v(" 语法")]),a._v(" "),t("p",[a._v("const wm = new weakMap()\n注：weakMap弱引用的只是键名而不是键值。键值依然是正常引用。")]),a._v(" "),t("h3",{attrs:{id:"与map结构的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#与map结构的区别"}},[a._v("#")]),a._v(" 与Map结构的区别")]),a._v(" "),t("ol",[t("li",[a._v("没有遍历操作，也没有size属性。")]),a._v(" "),t("li",[a._v("无法清空，即不支持clear()")])]),a._v(" "),t("h3",{attrs:{id:"方法-4"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#方法-4"}},[a._v("#")]),a._v(" 方法")]),a._v(" "),t("p",[a._v("● set()：设置key所对应的键值。"),t("br"),a._v("\n● get()：读取key对应的键值。"),t("br"),a._v("\n● delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。"),t("br"),a._v("\n● has(value)：返回一个布尔值，表示参数是否为Set的成员。")]),a._v(" "),t("h3",{attrs:{id:"用途"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#用途"}},[a._v("#")]),a._v(" 用途")]),a._v(" "),t("ol",[t("li",[a._v("以DOM节点作为键名（不计入垃圾回收机制）")]),a._v(" "),t("li",[a._v("部署私有属性（不会造成内存泄漏）")])])])}),[],!1,null,null,null);t.default=s.exports}}]);